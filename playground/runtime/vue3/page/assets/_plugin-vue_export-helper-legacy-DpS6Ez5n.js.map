{"version":3,"file":"_plugin-vue_export-helper-legacy-DpS6Ez5n.js","sources":["../../../../../../packages/utils/dist/tmagic-utils.js","../../../../../../runtime/vue-runtime-help/dist/hooks/use-app.js"],"sourcesContent":["import dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport { set, cloneDeep } from 'lodash-es';\nimport { NodeType } from '@tmagic/schema';\n\nconst asyncLoadJs = /* @__PURE__ */ (() => {\n  const documentMap = /* @__PURE__ */ new Map();\n  return (url, crossOrigin, document = globalThis.document) => {\n    let loaded = documentMap.get(document);\n    if (!loaded) {\n      loaded = /* @__PURE__ */ new Map();\n      documentMap.set(document, loaded);\n    }\n    if (loaded.get(url)) return loaded.get(url);\n    const load = new Promise((resolve, reject) => {\n      const script = document.createElement(\"script\");\n      script.type = \"text/javascript\";\n      if (crossOrigin) {\n        script.crossOrigin = crossOrigin;\n      }\n      script.src = url;\n      document.body.appendChild(script);\n      script.onload = () => {\n        resolve();\n      };\n      script.onerror = () => {\n        reject(new Error(\"加载失败\"));\n      };\n      setTimeout(() => {\n        reject(new Error(\"timeout\"));\n      }, 60 * 1e3);\n    }).catch((err) => {\n      loaded.delete(url);\n      throw err;\n    });\n    loaded.set(url, load);\n    return loaded.get(url);\n  };\n})();\nconst asyncLoadCss = /* @__PURE__ */ (() => {\n  const documentMap = /* @__PURE__ */ new Map();\n  return (url, document = globalThis.document) => {\n    let loaded = documentMap.get(document);\n    if (!loaded) {\n      loaded = /* @__PURE__ */ new Map();\n      documentMap.set(document, loaded);\n    }\n    if (loaded.get(url)) return loaded.get(url);\n    const load = new Promise((resolve, reject) => {\n      const node = document.createElement(\"link\");\n      node.rel = \"stylesheet\";\n      node.href = url;\n      document.head.appendChild(node);\n      node.onload = () => {\n        resolve();\n      };\n      node.onerror = () => {\n        reject(new Error(\"加载失败\"));\n      };\n      setTimeout(() => {\n        reject(new Error(\"timeout\"));\n      }, 60 * 1e3);\n    }).catch((err) => {\n      loaded.delete(url);\n      throw err;\n    });\n    loaded.set(url, load);\n    return loaded.get(url);\n  };\n})();\nconst addClassName = (el, doc, className) => {\n  const oldEl = doc.querySelector(`.${className}`);\n  if (oldEl && oldEl !== el) removeClassName(oldEl, className);\n  if (!el.classList.contains(className)) el.classList.add(className);\n};\nconst removeClassName = (el, ...className) => {\n  el.classList.remove(...className);\n};\nconst removeClassNameByClassName = (doc, className) => {\n  const el = doc.querySelector(`.${className}`);\n  el?.classList.remove(className);\n  return el;\n};\nconst injectStyle = (doc, style) => {\n  const styleEl = doc.createElement(\"style\");\n  styleEl.innerHTML = style;\n  doc.head.appendChild(styleEl);\n  return styleEl;\n};\nconst createDiv = ({ className, cssText }) => {\n  const el = globalThis.document.createElement(\"div\");\n  el.className = className;\n  el.style.cssText = cssText;\n  return el;\n};\nconst getDocument = () => globalThis.document;\nconst calcValueByFontsize = (doc, value) => {\n  if (!doc) return value;\n  const { fontSize } = doc.documentElement.style;\n  if (fontSize) {\n    const times = globalThis.parseFloat(fontSize) / 100;\n    return Number((value / times).toFixed(2));\n  }\n  return value;\n};\nconst dslDomRelateConfig = {\n  getIdFromEl: (el) => el?.dataset?.tmagicId,\n  getElById: (doc, id) => doc?.querySelector(`[data-tmagic-id=\"${id}\"]`),\n  setIdToEl: (el, id) => {\n    el.dataset.tmagicId = `${id}`;\n  }\n};\nconst setDslDomRelateConfig = (name, value) => {\n  dslDomRelateConfig[name] = value;\n};\nconst getIdFromEl = () => dslDomRelateConfig.getIdFromEl;\nconst getElById = () => dslDomRelateConfig.getElById;\nconst setIdToEl = () => dslDomRelateConfig.setIdToEl;\n\nconst sleep = (ms) => new Promise((resolve) => {\n  const timer = setTimeout(() => {\n    clearTimeout(timer);\n    resolve();\n  }, ms);\n});\nconst datetimeFormatter = (v, defaultValue = \"-\", format = \"YYYY-MM-DD HH:mm:ss\") => {\n  if (v) {\n    let time;\n    if ([\"x\", \"timestamp\"].includes(format)) {\n      time = dayjs(v).valueOf();\n    } else if (typeof v === \"string\" && v.includes(\"Z\") || v.constructor === Date) {\n      dayjs.extend(utc);\n      time = dayjs(v).utcOffset(8).format(format);\n    } else {\n      time = dayjs(v).format(format);\n    }\n    if (time !== \"Invalid Date\") {\n      return time;\n    }\n    return defaultValue;\n  }\n  return defaultValue;\n};\nconst toLine = (name = \"\") => name.replace(/\\B([A-Z])/g, \"-$1\").toLowerCase();\nconst toHump = (name = \"\") => name.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\nconst emptyFn = () => void 0;\nconst getNodePath = (id, data = []) => {\n  const path = [];\n  const get = function(id2, data2) {\n    if (!Array.isArray(data2)) {\n      return null;\n    }\n    for (let i = 0, l = data2.length; i < l; i++) {\n      const item = data2[i];\n      path.push(item);\n      if (`${item.id}` === `${id2}`) {\n        return item;\n      }\n      if (item.items) {\n        const node = get(id2, item.items);\n        if (node) {\n          return node;\n        }\n      }\n      path.pop();\n    }\n    return null;\n  };\n  get(id, data);\n  return path;\n};\nconst filterXSS = (str) => str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\");\nconst getUrlParam = (param, url) => {\n  const u = url || location.href;\n  const reg = new RegExp(`[?&#]${param}=([^&#]+)`, \"gi\");\n  const matches = u.match(reg);\n  let strArr;\n  if (matches && matches.length > 0) {\n    strArr = matches[matches.length - 1].split(\"=\");\n    if (strArr && strArr.length > 1) {\n      return filterXSS(strArr[1]);\n    }\n    return \"\";\n  }\n  return \"\";\n};\nconst isObject = (obj) => Object.prototype.toString.call(obj) === \"[object Object]\";\nconst isPop = (node) => Boolean(node?.type?.toLowerCase().endsWith(\"pop\"));\nconst isPage = (node) => {\n  if (!node) return false;\n  return Boolean(node.type?.toLowerCase() === NodeType.PAGE);\n};\nconst isPageFragment = (node) => {\n  if (!node) return false;\n  return Boolean(node.type?.toLowerCase() === NodeType.PAGE_FRAGMENT);\n};\nconst isNumber = (value) => /^(-?\\d+)(\\.\\d+)?$/.test(value);\nconst getHost = (targetUrl) => targetUrl.match(/\\/\\/([^/]+)/)?.[1];\nconst isSameDomain = (targetUrl = \"\", source = globalThis.location.host) => {\n  const isHttpUrl = /^(http[s]?:)?\\/\\//.test(targetUrl);\n  if (!isHttpUrl) return true;\n  return getHost(targetUrl) === source;\n};\nconst guid = (digit = 8) => \"x\".repeat(digit).replace(/[xy]/g, (c) => {\n  const r = Math.random() * 16 | 0;\n  const v = c === \"x\" ? r : r & 3 | 8;\n  return v.toString(16);\n});\nconst getKeysArray = (keys) => (\n  // 将 array[0] 转成 array.0\n  `${keys}`.replaceAll(/\\[(\\d+)\\]/g, \".$1\").split(\".\")\n);\nconst getValueByKeyPath = (keys = \"\", data = {}) => {\n  const keyArray = Array.isArray(keys) ? keys : getKeysArray(keys);\n  return keyArray.reduce((accumulator, currentValue) => {\n    if (isObject(accumulator)) {\n      return accumulator[currentValue];\n    }\n    if (Array.isArray(accumulator) && /^\\d*$/.test(`${currentValue}`)) {\n      return accumulator[currentValue];\n    }\n    throw new Error(`${data}中不存在${keys}`);\n  }, data);\n};\nconst setValueByKeyPath = (keys, value, data = {}) => set(data, keys, value);\nconst getNodes = (ids, data = []) => {\n  const nodes = [];\n  const get = function(ids2, data2) {\n    if (!Array.isArray(data2)) {\n      return;\n    }\n    for (let i = 0, l = data2.length; i < l; i++) {\n      const item = data2[i];\n      const index = ids2.findIndex((id) => `${id}` === `${item.id}`);\n      if (index > -1) {\n        ids2.slice(index, 1);\n        nodes.push(item);\n      }\n      if (item.items) {\n        get(ids2, item.items);\n      }\n    }\n  };\n  get(ids, data);\n  return nodes;\n};\nconst getDepKeys = (dataSourceDeps = {}, nodeId) => Array.from(\n  Object.values(dataSourceDeps).reduce((prev, cur) => {\n    (cur[nodeId]?.keys || []).forEach((key) => prev.add(key));\n    return prev;\n  }, /* @__PURE__ */ new Set())\n);\nconst getDepNodeIds = (dataSourceDeps = {}) => Array.from(\n  Object.values(dataSourceDeps).reduce((prev, cur) => {\n    Object.keys(cur).forEach((id) => {\n      prev.add(id);\n    });\n    return prev;\n  }, /* @__PURE__ */ new Set())\n);\nconst replaceChildNode = (newNode, data, parentId) => {\n  const path = getNodePath(newNode.id, data);\n  const node = path.pop();\n  let parent = path.pop();\n  if (parentId) {\n    parent = getNodePath(parentId, data).pop();\n  }\n  if (!node) throw new Error(\"未找到目标节点\");\n  if (!parent) throw new Error(\"未找到父节点\");\n  const index = parent.items?.findIndex((child) => child.id === node.id);\n  parent.items.splice(index, 1, newNode);\n};\nconst DSL_NODE_KEY_COPY_PREFIX = \"__tmagic__\";\nconst IS_DSL_NODE_KEY = \"__tmagic__dslNode\";\nconst compiledNode = (compile, node, dataSourceDeps = {}, sourceId) => {\n  let keys = [];\n  if (!sourceId) {\n    keys = getDepKeys(dataSourceDeps, node.id);\n  } else {\n    const dep = dataSourceDeps[sourceId];\n    keys = dep?.[node.id].keys || [];\n  }\n  keys.forEach((key) => {\n    const keys2 = getKeysArray(key);\n    const cacheKey = keys2.map((key2, index) => {\n      if (index < keys2.length - 1) {\n        return key2;\n      }\n      return `${DSL_NODE_KEY_COPY_PREFIX}${key2}`;\n    });\n    let templateValue = getValueByKeyPath(cacheKey, node);\n    if (typeof templateValue === \"undefined\") {\n      try {\n        const value = getValueByKeyPath(key, node);\n        setValueByKeyPath(cacheKey.join(\".\"), value, node);\n        templateValue = value;\n      } catch (e) {\n        console.warn(e);\n        return;\n      }\n    }\n    let newValue;\n    try {\n      newValue = compile(templateValue);\n    } catch (e) {\n      console.error(e);\n      newValue = \"\";\n    }\n    setValueByKeyPath(key, newValue, node);\n  });\n  return node;\n};\nconst compiledCond = (op, fieldValue, inputValue, range = []) => {\n  if (typeof fieldValue === \"string\" && typeof inputValue === \"undefined\") {\n    inputValue = \"\";\n  }\n  switch (op) {\n    case \"is\":\n      return fieldValue === inputValue;\n    case \"not\":\n      return fieldValue !== inputValue;\n    case \"=\":\n      return fieldValue === inputValue;\n    case \"!=\":\n      return fieldValue !== inputValue;\n    case \">\":\n      return fieldValue > inputValue;\n    case \">=\":\n      return fieldValue >= inputValue;\n    case \"<\":\n      return fieldValue < inputValue;\n    case \"<=\":\n      return fieldValue <= inputValue;\n    case \"between\":\n      return range.length > 1 && fieldValue >= range[0] && fieldValue <= range[1];\n    case \"not_between\":\n      return range.length < 2 || fieldValue < range[0] || fieldValue > range[1];\n    case \"include\":\n      return fieldValue?.includes?.(inputValue);\n    case \"not_include\":\n      return typeof fieldValue === \"undefined\" || !fieldValue.includes?.(inputValue);\n  }\n  return false;\n};\nconst getDefaultValueFromFields = (fields) => {\n  const data = {};\n  const defaultValue = {\n    string: void 0,\n    object: {},\n    array: [],\n    boolean: void 0,\n    number: void 0,\n    null: null,\n    any: void 0\n  };\n  fields.forEach((field) => {\n    if (typeof field.defaultValue !== \"undefined\") {\n      if (field.type === \"array\" && !Array.isArray(field.defaultValue)) {\n        data[field.name] = defaultValue.array;\n        return;\n      }\n      if (field.type === \"object\" && !isObject(field.defaultValue)) {\n        if (typeof field.defaultValue === \"string\") {\n          try {\n            data[field.name] = JSON.parse(field.defaultValue);\n          } catch (e) {\n            data[field.name] = defaultValue.object;\n          }\n          return;\n        }\n        data[field.name] = defaultValue.object;\n        return;\n      }\n      data[field.name] = cloneDeep(field.defaultValue);\n      return;\n    }\n    if (field.type === \"object\") {\n      data[field.name] = field.fields ? getDefaultValueFromFields(field.fields) : defaultValue.object;\n      return;\n    }\n    if (field.type) {\n      data[field.name] = defaultValue[field.type];\n      return;\n    }\n    data[field.name] = void 0;\n  });\n  return data;\n};\nconst DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX = \"ds-field::\";\nconst DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX = \"ds-field-changed\";\nconst getKeys = Object.keys;\nconst calculatePercentage = (value, percentageStr) => {\n  const percentage = globalThis.parseFloat(percentageStr) / 100;\n  const result = value * percentage;\n  return result;\n};\nconst isPercentage = (value) => /^(\\d+)(\\.\\d+)?%$/.test(`${value}`);\nconst convertToNumber = (value, parentValue = 0) => {\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\" && isPercentage(value)) {\n    return calculatePercentage(parentValue, value);\n  }\n  return parseFloat(value);\n};\nconst addParamToUrl = (obj, global = globalThis, needReload = true) => {\n  const url = new URL(global.location.href);\n  const { searchParams } = url;\n  for (const [k, v] of Object.entries(obj)) {\n    searchParams.set(k, v);\n  }\n  const newUrl = url.toString();\n  if (needReload) {\n    global.location.href = newUrl;\n  } else {\n    global.history.pushState({}, \"\", url);\n  }\n};\nconst dataSourceTemplateRegExp = /\\$\\{([\\s\\S]+?)\\}/g;\nconst isDslNode = (config) => typeof config[IS_DSL_NODE_KEY] === \"undefined\" || config[IS_DSL_NODE_KEY] === true;\n\nexport { DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX, DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX, DSL_NODE_KEY_COPY_PREFIX, IS_DSL_NODE_KEY, addClassName, addParamToUrl, asyncLoadCss, asyncLoadJs, calcValueByFontsize, calculatePercentage, compiledCond, compiledNode, convertToNumber, createDiv, dataSourceTemplateRegExp, datetimeFormatter, emptyFn, filterXSS, getDefaultValueFromFields, getDepKeys, getDepNodeIds, getDocument, getElById, getHost, getIdFromEl, getKeys, getKeysArray, getNodePath, getNodes, getUrlParam, getValueByKeyPath, guid, injectStyle, isDslNode, isNumber, isObject, isPage, isPageFragment, isPercentage, isPop, isSameDomain, removeClassName, removeClassNameByClassName, replaceChildNode, setDslDomRelateConfig, setIdToEl, setValueByKeyPath, sleep, toHump, toLine };\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2023 THL A29 Limited, a Tencent company.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { inject, onBeforeUnmount, onMounted } from 'vue-demi';\nimport { isDslNode } from '@tmagic/utils';\nexport const useApp = ({ methods = {}, config, iteratorContainerId, iteratorIndex }) => {\n    const app = inject('app');\n    const emitData = {\n        config,\n        ...methods,\n    };\n    const display = (config) => {\n        if (config.visible === false)\n            return false;\n        if (config.condResult === false)\n            return false;\n        const displayCfg = config.display;\n        if (typeof displayCfg === 'function') {\n            return displayCfg(app);\n        }\n        return displayCfg !== false;\n    };\n    const node = isDslNode(config) && config.id ? app?.getNode(config.id, iteratorContainerId, iteratorIndex) : undefined;\n    if (node) {\n        node.emit('created', emitData);\n        onMounted(() => {\n            node.emit('mounted', emitData);\n        });\n        onBeforeUnmount(() => {\n            node.emit('destroy', emitData);\n        });\n    }\n    return {\n        app,\n        node,\n        display,\n    };\n};\n"],"names":["exports","name","replace","toLowerCase","IS_DSL_NODE_KEY","methods","config","iteratorContainerId","iteratorIndex","app","VueDemi","inject","emitData","node","isDslNode","id","getNode","undefined","emit","onMounted","onBeforeUnmount","display","visible","condResult","displayCfg"],"mappings":"oHA+IeA,EAAA,KAAA,CAACC,EAAO,KAAOA,EAAKC,QAAQ,aAAc,OAAOC,gBAA3D,MAkICC,QAAkB,qBC9PxBJ,EAAA,KAAA,EAAAK,UAAA,CAAA,EAAAC,SAAAC,sBAAAC,oBACA,MAAAC,EAAgBC,QAAMC,OAAA,OACtBC,EAAA,CACAN,YACAD,GAaAQ,EDgYmBP,SAA8C,IAA5BA,EAAOF,KAAgE,IAA5BE,EAAOF,GChYvFU,CAAAR,IAAAA,EAAAS,GAAAN,GAAAO,QAAAV,EAAAS,GAAAR,EAAAC,QAAAS,EAUA,OATAJ,IACAA,EAAAK,KAAA,UAAAN,GACQF,QAASS,WAAA,KACjBN,EAAAK,KAAA,UAAAN,EAAA,IAEQF,QAAeU,iBAAA,KACvBP,EAAAK,KAAA,UAAAN,EAAA,KAGA,CACAH,MACAI,OACAQ,QAxBAf,IACA,IAAA,IAAAA,EAAAgB,QACA,OAAA,EACA,IAAA,IAAAhB,EAAAiB,WACA,OAAA,EACA,MAAAC,EAAAlB,EAAAe,QACA,MAAA,mBAAAG,EACAA,EAAAf,IAEA,IAAAe,CAAA,EAgBA"}